# Progress — 2026-02-17

## Work Done: Protocol Setup Validation

Added gantry config loading, bounds validation, and protocol setup orchestration to ensure protocols are safe to run before execution.

### New Modules

**`src/gantry/`** — Gantry config loading
- `yaml_schema.py`: Pydantic schemas (`GantryYamlSchema`, `WorkingVolumeYaml`, `CncYaml`) with strict validation (extra="forbid", min < max for all axes, homing strategy literal)
- `gantry_config.py`: `GantryConfig` and `WorkingVolume` frozen dataclasses. `WorkingVolume.contains(x, y, z)` checks inclusive bounds.
- `loader.py`: `load_gantry_from_yaml()` + `load_gantry_from_yaml_safe()` with user-friendly error messages
- `errors.py`: `GantryLoaderError`

**`src/validation/`** — Bounds validation
- `bounds.py`: `validate_deck_positions(gantry, deck)` checks every labware position (all wells, all vial locations) against gantry bounds. `validate_gantry_positions(gantry, deck, board)` checks computed gantry positions for every (instrument, position) combination using formula `gantry_pos = deck_pos - instrument_offset`.
- `errors.py`: `BoundsViolation` dataclass and `SetupValidationError` exception (collects all violations before raising)

**`src/protocol_engine/setup.py`** — Protocol setup orchestrator
- `setup_protocol(gantry_path, deck_path, board_path, protocol_path, gantry=None)` loads all four configs, runs both validation passes, returns `(Protocol, ProtocolContext)` ready to run
- Uses mock gantry by default for offline validation

### Modified Files
- `src/protocol_engine/protocol.py`: Added optional `gantry: GantryConfig | None = None` field to `ProtocolContext` (backward-compatible)
- `README.md`: Added gantry config, validation, setup sections; updated config paths
- `AGENTS.md`: Added gantry, validation, setup sections; updated config paths; added config directory structure
- `configs/decks/deck.sample.yaml`: Updated path reference in comment
- `configs/protocols/protocol.sample.yaml`: Updated path reference in comment

### Config Reorganization
Moved all config files from flat `configs/` into typed subdirectories:
- `configs/gantries/` — gantry YAML (genmitsu_3018_PRO_Desktop.yaml, genmitsu_3018_PROver_v2.yaml)
- `configs/decks/` — deck YAML (deck.sample.yaml, mofcat_deck.yaml)
- `configs/boards/` — board YAML (mofcat_board.yaml)
- `configs/protocols/` — protocol YAML (protocol.sample.yaml)

### Test Files Created
- `tests/gantry/test_yaml_schema.py` — 19 tests (schema field validation, bounds ordering, extra key rejection)
- `tests/gantry/test_gantry_config.py` — 14 tests (WorkingVolume.contains, boundary edge cases, frozen dataclass)
- `tests/gantry/test_loader.py` — 15 tests (happy path, missing file, invalid YAML, safe wrapper)
- `tests/validation/test_bounds_validation.py` — 24 tests (deck bounds, gantry bounds, edge cases, error detail)
- `tests/setup/test_protocol_setup.py` — 12 tests (full setup, missing files, bounds violations, mock gantry)
- `tests/setup/test_integration.py` — 5 tests (end-to-end with all 4 YAML configs, protocol execution)

### Test Results
- New tests: 89
- Existing tests: 329 (all passing, no regressions)
- Total: 418 tests passing

### Key Design Decisions
- Validation returns `list[BoundsViolation]` (not fail-fast) so all issues are reported at once
- Inclusive boundaries: position exactly on x_min or x_max is valid
- Gantry position formula replicated from `Board.move()` for offline validation
- `ProtocolContext.gantry` is optional for backward compatibility
- Config files organized by type for clarity

---

## CLI Validation Script — `setup/validate_setup.py`

Added a runnable CLI script that loads all 4 config files and prints human-readable validation output.

### Usage
```bash
python setup/validate_setup.py \
    configs/gantries/genmitsu_3018_PROver_v2.yaml \
    configs/decks/mofcat_deck.yaml \
    configs/boards/mofcat_board.yaml \
    configs/protocols/protocol.sample.yaml
```

### Output
Step-by-step output showing:
1. Each config loaded with details (gantry working volume bounds, labware list with well counts, instruments with offsets, protocol steps)
2. Deck position validation results (PASS/FAIL with violation details)
3. Gantry position validation results (PASS/FAIL with violation details)
4. Final PASS/FAIL summary

The script uses a mock gantry for offline validation — no hardware connection needed.

### Files
- `setup/validate_setup.py` (new) — CLI script with `run_validation()` function
- `README.md` (modified) — added validate_setup usage section
- `AGENTS.md` (modified) — added validate_setup.py description

---

## Protocol Runner Script — `setup/run_protocol.py`

Added a script that validates and runs a protocol end-to-end with real hardware.

### Flow
1. Runs offline validation (reuses `validate_setup.py` output)
2. Creates Gantry from raw gantry config
3. Calls `setup_protocol()` with real gantry for config loading + validation
4. Connects to gantry, homes
5. Runs `protocol.run(context)`
6. Disconnects (in `finally` block)

### Usage
```bash
python setup/run_protocol.py \
    configs/gantries/genmitsu_3018_PROver_v2.yaml \
    configs/decks/mofcat_deck.yaml \
    configs/boards/mofcat_board.yaml \
    configs/protocols/protocol.sample.yaml
```

### Files
- `setup/run_protocol.py` (new) — end-to-end protocol runner
- `README.md` (modified) — added run_protocol usage section
- `AGENTS.md` (modified) — added run_protocol.py description

---

## Machine to Gantry Refactor

Performed a strict repository-wide terminology refactor so machine config code and references now use gantry naming and live under the existing `src/gantry` module.

### Work Done
- Added gantry config modules in `src/gantry/`:
  - `gantry_config.py` (`GantryConfig`, `WorkingVolume`)
  - `yaml_schema.py` (`GantryYamlSchema`)
  - `loader.py` (`load_gantry_from_yaml`, `load_gantry_from_yaml_safe`)
  - `errors.py` (`GantryLoaderError`)
  - Updated `src/gantry/__init__.py` exports
- Updated protocol/setup/validation contracts:
  - `ProtocolContext.machine` -> `ProtocolContext.gantry`
- `setup_protocol(...)` now uses `gantry_path` naming for the config argument
  - Bounds validators now accept `gantry: GantryConfig`
- Updated setup scripts and calibration naming:
  - `setup/validate_setup.py` and `setup/run_protocol.py` usage/help text now use `<gantry.yaml>`
  - Added `calibration/home_gantry.py` pointing at `configs/gantries/...`
  - Updated `setup/hello_world.py` wording and config paths
- Reorganized config paths:
  - Added `configs/gantries/genmitsu_3018_PROver_v2.yaml`
  - Added `configs/gantries/genmitsu_3018_PRO_Desktop.yaml`
- Added TDD-first renamed tests:
  - `tests/gantry/test_gantry_config.py`
  - `tests/gantry/test_loader.py`
  - `tests/gantry/test_yaml_schema.py`
  - Updated impacted setup/validation tests for gantry naming

### Issues Found and Resolved
- Initial red state after test rename: `ModuleNotFoundError` for missing `src.gantry` config modules.
- Resolved by implementing gantry config/schema/loader/error modules and updating all impacted imports/contracts.

### Verification
- Ran focused refactor suites:
  - `pytest tests/gantry tests/validation/test_bounds_validation.py tests/setup/test_protocol_setup.py tests/setup/test_integration.py -q`
  - Result: `95 passed`

### Follow-up Fix: `validate_setup.py` variable shadowing
- Found runtime error where `gantry` was reused for two different concepts:
  - loaded `GantryConfig` from YAML
  - mock gantry hardware object for board loading
- This caused bounds validation to receive a mock object (without `working_volume`) and fail with:
  - `AttributeError: Mock object has no attribute 'working_volume'`
- Fix applied in `setup/validate_setup.py`:
  - `gantry_config` now stores the loaded config
  - `mock_gantry` is used only for `load_board_from_yaml(...)`
  - Bounds validation now consistently uses `gantry_config`
- Verification:
  - `pytest tests/setup/test_protocol_setup.py tests/setup/test_integration.py tests/validation/test_bounds_validation.py -q`
  - Result: `41 passed`

---

## PR Review Fixes (Session 2)

Comprehensive code review identified 21 issues across the protocol setup validation branch. All issues fixed in this session.

### Critical Fixes

1. **`setup/run_protocol.py` — validation result ignored**
   - `run_validation()` output was printed but result never checked; execution proceeded regardless of PASS/FAIL/ERROR
   - Fix: `run_validation()` now returns `ValidationResult(output, passed)` dataclass; `run_protocol.py` checks `result.passed` and aborts with `sys.exit(1)` if validation fails

2. **`setup/run_protocol.py` — runtime errors swallowed with exit code 0**
   - `except Exception` caught all errors during protocol execution but exited with code 0
   - Fix: Added `sys.exit(1)` after error handler, added `traceback.print_exc()` for debugging, `KeyboardInterrupt` exits with code 130

3. **`setup/run_protocol.py` — health check failure ignored**
   - Failed `gantry.is_healthy()` printed a warning but continued to execute the protocol
   - Fix: Health check failure now prints error, disconnects, and exits with `sys.exit(1)`

4. **`configs/protocols/protocol.sample.yaml` — broken YAML**
   - Line 36 had `── Scan ──` without `#` prefix, making it invalid YAML syntax
   - Fix: Added `#` prefix to make it a comment

### Important Fixes

5. **`setup/run_protocol.py` — stale docstring**
   - Docstring said "3. Connect to gantry and home" but no homing code exists
   - Fix: Updated to "3. Connect to gantry"

6. **`src/protocol_engine/setup.py` — `MagicMock` in production code**
   - `unittest.mock.MagicMock` used to create a fake gantry for offline validation
   - Fix: Created `src/gantry/offline.py` with `OfflineGantry` class providing the same interface as `Gantry` without hardware; replaced all MagicMock usage

7. **`src/protocol_engine/setup.py` — broad `except Exception` in `_load_*` helpers**
   - All 4 `_load_*` functions caught `Exception` and re-wrapped, which could mask programming bugs
   - Fix: Replaced `_load_*` helpers with direct calls to the `_safe` loader variants (e.g., `load_gantry_from_yaml_safe`) which already produce user-friendly errors

8. **`setup/validate_setup.py` — imported private `_default_mock_gantry`**
   - Fix: Replaced with public `OfflineGantry`

9. **`src/gantry/gantry_config.py` — `WorkingVolume` missing `__post_init__`**
   - No invariant enforcement that `min < max` for each axis
   - Fix: Added `__post_init__` that validates `{axis}_min < {axis}_max` for x, y, z; added 4 new tests

10. **`src/gantry/gantry_config.py` — `homing_strategy: str` loses type safety**
    - Pydantic schema uses `Literal["xy_hard_limits", "standard"]` but domain model stores plain `str`
    - Fix: Created `HomingStrategy(str, Enum)` with `XY_HARD_LIMITS` and `STANDARD` values; used in `GantryConfig` and loader

11. **Stale documentation references**
    - `AGENTS.md` and `README.md` referenced deleted `configs/genmitsu_3018_deck_config.yaml`
    - Fix: Updated to reference new config directory structure

12. **`configs/protocols/scan.yaml` — wrong file reference in comment**
    - Comment said to load `protocol.sample.yaml` instead of `scan.yaml`
    - Fix: Updated comment

### Code Quality Fixes

13. **`src/validation/bounds.py` — unused `Optional` import**
    - Fix: Removed

14. **`src/validation/bounds.py` — unknown labware types silently skipped**
    - `_get_all_positions` had no `else` clause; new labware types would be silently ignored
    - Fix: Added `else` clause with `logger.warning()` for unknown types

15. **`src/validation/errors.py` — mutable `violations` list**
    - `SetupValidationError.violations` was a mutable `list`
    - Fix: Stored as `tuple` for immutability

16. **`src/validation/errors.py` — `coordinate_type` and `axis` used plain `str`**
    - Fix: Changed to `Literal["deck", "gantry"]` and `Literal["x", "y", "z"]`

17. **`setup/validate_setup.py` — now returns structured `ValidationResult`**
    - Previously returned a plain string; callers couldn't programmatically check pass/fail
    - Fix: Returns `ValidationResult(output: str, passed: bool)` dataclass

### New Files
- `src/gantry/offline.py` — `OfflineGantry` stub class for offline validation

### Test Results
- 412 tests passing (excluding 8 pre-existing scan command failures unrelated to this PR)
- 5 new tests added (4 for WorkingVolume invariants, 1 for HomingStrategy enum)
- All gantry, setup, and validation tests pass: 100/100

---

## Import Path Fix for `setup/run_protocol.py` (Session 3)

Fixed a startup crash when running:

```bash
python setup/run_protocol.py \
    configs/gantries/genmitsu_3018_PROver_v2.yaml \
    configs/decks/mofcat_deck.yaml \
    configs/boards/mock_mofcat_board.yaml \
    configs/protocols/move.yaml
```

### Issue Found
- Error: `ModuleNotFoundError: No module named 'gantry'`
- Root cause: setup scripts inserted only project root into `sys.path`, while package imports (e.g. `gantry`, `instruments`) resolve from `src/`.

### Work Done
- Updated setup script path bootstrapping:
  - `setup/validate_setup.py`: add `project_root / "src"` to `sys.path`
  - `setup/run_protocol.py`: add `project_root / "src"` to `sys.path`
- Hardened board imports for mixed execution contexts:
  - `src/board/board.py`: compatibility import fallback for `BaseInstrument`; moved `Gantry` import to `TYPE_CHECKING`
  - `src/board/loader.py`: compatibility import fallback for instrument drivers; switched `Board` import to relative (`from .board import Board`); moved `Gantry` import to `TYPE_CHECKING`
- Added regression tests:
  - `tests/setup/test_setup_imports.py`
    - verifies `import setup.validate_setup` works with only project root on `PYTHONPATH`
    - verifies `import setup.run_protocol` works with only project root on `PYTHONPATH`

### Verification
- Red phase (before fix):
  - `pytest -q tests/setup/test_setup_imports.py`
  - Failed with `ModuleNotFoundError: No module named 'gantry'`
- Green phase (after fix):
  - `pytest -q tests/setup/test_setup_imports.py`
  - Result: `2 passed`

### Notes
- No hardware commands were run.
- Existing unrelated repo change remained untouched (`src/protocol_engine/protocol.py` was already modified in the working tree).
# Progress: 2026-02-17 — SQLite Data Persistence Layer

## Summary
Implemented a complete SQLite data persistence layer for PANDA_CORE. All state (labware volumes, well contents, measurements) lives in the database — Python labware objects are stateless to survive interrupts/crashes. An empty initialized database template is shipped at `data/databases/panda_data.db`.

## Work Completed

### DataStore Core (`data/data_store.py`)
- SQLite-backed `DataStore` class with 6 tables: `campaigns`, `experiments`, `uvvis_measurements`, `filmetrics_measurements`, `camera_measurements`, `labware`
- Foreign key enforcement via `PRAGMA foreign_keys = ON`
- BLOB serialization for UV-Vis spectra using `struct.pack('<Nd', ...)` — lossless round-trip for float64 arrays
- `log_measurement()` dispatches by `isinstance()` (UVVisSpectrum, MeasurementResult, or str)
- Context manager support
- **20 tests** in `tests/data/test_data_store.py`

### Labware Table (DB-persisted state)
- `labware` table tracks per-well/per-vial: `total_volume_ul`, `working_volume_ul`, `current_volume_ul`, `contents` (JSON)
- `register_labware(campaign_id, key, labware)` — creates 1 row per vial, 1 row per well for plates
- `record_dispense(campaign_id, key, well_id, source, volume)` — atomically increments volume and appends to contents JSON
- `get_contents(campaign_id, key, well_id)` — returns parsed contents list
- Duplicate registration check raises `ValueError`
- **15 tests** in `tests/data/test_labware_table.py`

### ProtocolContext Integration
- Added `data_store: Any = None` and `campaign_id: int | None = None` to `ProtocolContext`
- Both default to `None` — fully backward compatible
- **3 tests** in `tests/protocol_engine/test_protocol_context_data_store.py`

### Protocol Command Wiring
- **Bug fix in scan**: `callable_method(plate_obj)` → `callable_method()` — instruments take no args
- **Return type fix in scan**: `Dict[str, bool]` → `Dict[str, Any]`
- **Return type fixes in pipette**: `aspirate`, `dispense`, `mix` return `Any`
- **DB-based tracking**: `dispense` and `transfer` call `data_store.record_dispense()` when a DataStore is present
- **Scan logging**: snapshots contents from DB via `get_contents()`, creates experiment + measurement rows
- **Helper `_parse_position()`**: Splits `"plate_1.A1"` → `("plate_1", "A1")`
- **Fixed scan test**: `_FakeSensor.measure()` signature updated (removed plate arg)
- **7 tests** in `tests/data/test_command_logging.py`

### Documentation & Integration
- Updated `AGENTS.md` with Data Persistence section (DB-only state model)
- Updated `README.md` with usage example including `register_labware()`
- Empty `.db` template at `data/databases/panda_data.db`
- **2 integration tests** in `tests/data/test_integration.py`

## Key Design Decision: Stateless Python Objects
Initially implemented in-memory content tracking on `Vial.contents` and `WellPlate.contents`/`add_content()`. **Reverted** — Python objects are ephemeral and lose state on interrupt (power loss, unplug, crash). All state now lives in SQLite, which survives restarts. Labware models remain pure geometry/config.

## Issues Found and Resolved

1. **Scan command bug**: `callable_method(plate_obj)` was passing the plate to `measure()`, but all instruments' `measure()` methods take zero arguments.

2. **SQLite NULL uniqueness**: `UNIQUE(campaign_id, labware_key, well_id)` doesn't prevent duplicate NULLs in SQLite. Added explicit `COUNT(*)` check in `register_labware()` before inserting.

## PR Review Fixes (Session 2)

Ran comprehensive 4-agent PR review (code-reviewer, test-coverage-analyzer, silent-failure-hunter, comment-analyzer). Applied the following fixes:

### 1. `register_labware()` type guard (`data/data_store.py`)
- Added `isinstance(labware, Labware)` check at the top — raises `TypeError` for non-Labware inputs
- Added `else` clause after WellPlate/Vial branches for unsupported Labware subtypes
- Updated docstring with `Raises` section

### 2. Removed `dispense` as a YAML protocol command (`src/protocol_engine/commands/pipette.py`)
- Removed `@protocol_command("dispense")` decorator — `dispense()` is now a private helper, not exposed to user YAML
- Removed buggy DB logging from standalone `dispense()` (was using destination as source_name)
- Users should use `transfer` instead, which correctly tracks source labware
- Removed `test_dispense_records_to_labware_table` test (was testing the buggy behavior)

### 3. Error handling around DB logging
- Wrapped scan DB logging block in `try/except` with `logger.exception()` (`scan.py`)
- Wrapped `_record_dispense_to_store` body in `try/except` with `logger.exception()` (`pipette.py`)
- DB failures now log errors instead of crashing the experiment mid-run

### 4. Fixed `_parse_position()` return type (`pipette.py`)
- Changed bare `tuple` → `tuple[str, Optional[str]]`
- Added 4 unit tests in `TestParsePosition` class

### 5. Fixed `setup.cfg` package discovery conflict
- Removed `[options.packages.find]` section from `setup.cfg` — `pyproject.toml` is the single source of truth

### 6. Documentation fixes
- Updated `scan` docstring with DataStore side-effect note
- Fixed AGENTS.md: softened "atomically increments" to "increments" in `record_dispense` description
- Fixed AGENTS.md: removed `dispense` from auto-persist command list (only `scan` and `transfer` now)

## Test Count
- **Total: 396 tests, all passing**
- Session 1 new tests: 47 (20 + 15 + 3 + 7 + 2)
- Session 2: +4 (parse_position) −1 (removed dispense DB test) = net +3
- No regressions in existing test suite

## Files

### New files
| File | Purpose |
|------|---------|
| `data/__init__.py` | Package init, exports DataStore |
| `data/data_store.py` | SQLite DataStore class |
| `data/databases/panda_data.db` | Empty initialized database template |
| `tests/data/__init__.py` | Test package init |
| `tests/data/test_data_store.py` | DataStore CRUD + measurement tests |
| `tests/data/test_labware_table.py` | Labware table register/dispense/get tests |
| `tests/data/test_command_logging.py` | Command-level DB logging tests |
| `tests/data/test_integration.py` | End-to-end integration tests |
| `tests/protocol_engine/test_protocol_context_data_store.py` | ProtocolContext + DataStore tests |

### Modified files
| File | Change |
|------|--------|
| `src/protocol_engine/protocol.py` | Added `data_store`, `campaign_id` to ProtocolContext |
| `src/protocol_engine/commands/scan.py` | Fixed method call bug, fixed return type, added DB logging |
| `src/protocol_engine/commands/pipette.py` | Fixed return types, added DB-based dispense tracking |
| `tests/protocol_engine/test_scan_command.py` | Fixed `_FakeSensor.measure()` signature |
| `AGENTS.md` | Documented data persistence layer |
| `README.md` | Added data persistence usage example |
| `.gitignore` | Added SQLite journal file exclusions |
| `pyproject.toml` | Added project root to package discovery |
| `setup.cfg` | Updated package discovery |

## Session: Fix pytest import collection failures

### What I changed
- Added pytest path configuration in `pyproject.toml`:
  - `[tool.pytest.ini_options]`
  - `pythonpath = ["src", "."]`
- This ensures test collection can import top-level packages that live under `src/` (`deck`, `gantry`, `instruments`, `protocol_engine`, `board`) and root package `data`.

### Why this was failing
- The test suite imports modules as top-level packages (for example, `from deck import ...`).
- Without `src` on Python import path during pytest collection, imports fail with `ModuleNotFoundError` before tests run.

### Impact
- Addresses the shared root cause behind the 26 import-time collection errors shown in terminal output.
- No hardware-facing runtime logic was changed.

### Notes
- I have not executed pytest yet in this session; waiting for explicit permission because tests include CNC/instrument-related modules and your rule requires approval before running anything potentially hardware-related.

---

## Volume Tracking for Labware and Pipetting Validation

### Summary
Added in-memory volume tracking for all labware (wells and vials) with fail-fast validation on every pipetting operation. Each labware location tracks its current volume and capacity. Aspirate, dispense, transfer, mix, and serial_transfer commands all validate volumes before moving hardware.

### Architecture
- **`VolumeTracker`** — pure in-memory tracker (dict-based, O(1) lookups) with no DB dependency
- Attached to `ProtocolContext.volume_tracker` (optional, backward-compatible)
- Validates **before** hardware commands execute (fail-fast safety)
- When `volume_tracker` is `None`, all commands work exactly as before

### New Files
| File | Purpose |
|------|---------|
| `src/protocol_engine/volume_tracker.py` | Core VolumeTracker class (registration, queries, validation, recording) |
| `tests/protocol_engine/test_volume_errors.py` | 15 tests for VolumeError hierarchy |
| `tests/protocol_engine/test_volume_tracker.py` | 45 tests for VolumeTracker core logic |
| `tests/protocol_engine/test_pipette_commands_volume_validation.py` | 23 tests for command-level volume validation |
| `tests/data/test_record_aspirate.py` | 5 tests for DataStore.record_aspirate |
| `tests/test_initial_volume.py` | 10 tests for initial_volume_ul on Vial model and YAML |

### Modified Files
| File | Change |
|------|--------|
| `src/protocol_engine/errors.py` | Added VolumeError, OverflowVolumeError, UnderflowVolumeError, InvalidVolumeError, PipetteVolumeError |
| `src/protocol_engine/protocol.py` | Added `volume_tracker` field to ProtocolContext |
| `src/protocol_engine/commands/pipette.py` | Integrated volume validation into aspirate, dispense, transfer, mix, serial_transfer; added `_validate_pipette_volume`, `_record_aspirate_to_store` helpers |
| `data/data_store.py` | Added `record_aspirate()` method (decrements current_volume_ul) |
| `src/deck/labware/vial.py` | Added `initial_volume_ul` field (default 0.0) with validation |
| `src/deck/yaml_schema.py` | Added `initial_volume_ul` to VialYamlEntry (default 0.0) |
| `configs/deck/deck.sample.yaml` | Added `initial_volume_ul: 1000.0` to sample vial |
| `AGENTS.md` | Documented VolumeTracker, error hierarchy, initial_volume_ul |
| `README.md` | Added Volume Tracking section, fixed merge conflict markers |

### Validations Enforced
1. **Underflow** — cannot aspirate more than available volume from source
2. **Overflow** — cannot dispense beyond a well/vial's capacity
3. **Pipette range** — volumes must be within pipette's min/max range (e.g., P300: 20-200 uL)
4. **Invalid values** — rejects negative, zero, NaN, and infinite volumes
5. **Mix** — validates well has enough volume for the aspirate portion (net zero change)
6. **Serial transfer** — cumulative source depletion tracked across all transfers in the series

### Error Hierarchy
```
ProtocolExecutionError
  └── VolumeError
        ├── OverflowVolumeError (labware_key, well_id, current_volume, requested, capacity)
        ├── UnderflowVolumeError (labware_key, well_id, current_volume, requested)
        ├── InvalidVolumeError (negative, zero, NaN, infinity)
        └── PipetteVolumeError (requested, min_ul, max_ul)
```

### Test Results
- **590 tests passing** (was 492 — 98 new tests, zero regressions)
- TDD approach: all tests written and verified failing before implementation

### Key Design Decisions
1. **In-memory tracker over DB-only** — VolumeTracker operates in pure Python with O(1) lookups, no SQLite dependency. DataStore remains as secondary persistence.
2. **Fail-fast before hardware** — all validation happens before gantry moves or pipette actuates. Failed validation means no physical action occurs.
3. **Backward compatible** — `volume_tracker=None` (default) means zero behavior change. All 492 existing tests pass unchanged.
4. **initial_volume_ul on Vial model** — configuration data (not runtime state) so it fits the immutable Pydantic model pattern. VolumeTracker uses it as starting point.
