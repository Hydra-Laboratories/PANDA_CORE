## Labware abstractions and tests

## Protocol engine readiness check (96-well initial-position compile)

- **Goal reviewed**
  - Verify whether the current protocol engine (after recent `instruments`, `labware`, and `gantry` revisions) can compile a YAML protocol that moves to the initial position of a 96-well plate from deck configuration.

- **What was checked**
  - Read and traced `src/protocol_engine/{schema,config,path_planner,compiler,executor}.py`.
  - Read revised modules:
    - `src/labware/{labware,well_plate,vial}.py`
    - `src/instrument_drivers/cnc_driver/instruments.py`
    - `src/hardware/gantry.py`
  - Performed dry compile (no hardware): `ExperimentSequence.from_yaml(...) -> Compiler(config).compile(...)`.
  - Ran `pytest -q tests/test_protocol_engine.py` to detect API drift.

- **Findings**
  - Compile path currently resolves targets **only** from `DeckConfig.locations` (flat map). No integration exists that maps labware definitions (e.g., plate + `A1`) into compiler targets.
  - `MoveAction.instrument` is accepted in schema but currently unused during compile. No instrument offset application is performed.
  - A deck YAML containing `labware:` (without explicit `locations:` entries for targets) fails compile with `Unknown location for move action: ...`.
  - Dry run with existing flat `locations:` config compiles successfully.
  - Test/API drift detected: `ProtocolExecutor` now expects `gantry`, while existing test still instantiates with `mill`.

- **Conclusion**
  - Current engine can compile simple move protocols **only when all targets are pre-flattened into `locations`**.
  - It is **not yet ready** for the desired workflow where the protocol is driven directly from deck-level labware + instrument configuration for `96_well_plate.initial_position (A1)` semantics.

- **What was done**
  - Introduced a new top-level `labware` package with `Coordinate3D`, `Labware`, `WellPlate`, and `Vial` models.
  - Added `tests/test_labware.py` covering validation, geometry metadata, and coordinate resolution for wells and vial positions.
  - Ensured all new models use Pydantic v2-style validators and integrate cleanly with the existing test suite.

- **Key design decisions**
  - Labware coordinates are represented as absolute deck coordinates (machine space), matching how future YAML config will specify well/vial centers.
  - `Labware` provides a generic `get_location(location_id)` API, while `WellPlate` and `Vial` add ergonomic `get_well_center` / `get_vial_center` helpers.
  - `WellPlate` and `Vial` mirror their domain-specific mappings (`wells`, `vials`) into the base `locations` mapping so higher-level code can treat all labware uniformly.

- **Issues encountered and resolutions**
  - **Pydantic v2 validator changes**: Initial implementation used deprecated `@validator`/`@root_validator`, which caused runtime errors. Updated to `@field_validator` and `@model_validator` (mode `"before"` for subclasses) to align with Pydantic v2 semantics.
  - **Validator ordering across inheritance**: The base `Labware` model enforces that at least one `location` exists, but subclasses compute `locations` from `wells`/`vials`. Fixed this by:
    - Making `locations` optional with a default empty dict on `Labware`.
    - Using subclass `@model_validator(mode=\"before\")` hooks to inject `locations` from `wells`/`vials` before the base validator runs.

- **Next steps**
  - Extend deck/protocol configuration to define labware in YAML (dimensions and per-well/vial centers).
  - Integrate labware resolution into the protocol compiler/path planner so movement scripts can target logical IDs like `\"plate_1.A1\"` or `\"vial_rack.A1\"`.

## Labware initial-position semantics

- **What was refined**
  - Introduced a labware-level `get_initial_position()` API on `Labware` to distinguish between the labware anchor and individual target locations.
  - Updated `WellPlate` so its initial position is explicitly the `A1` well; validation now enforces that an `A1` entry exists in `wells`.
  - Updated `Vial` to include an explicit `center` coordinate, and `get_initial_position()` returns this center while still supporting per-vial IDs via the `vials` mapping.

- **Why**
  - For well plates, there is no single geometric “center” that should be used for motion anchoring; operationally, `A1` is the natural reference.
  - For vial labware, the central position is the natural anchor for safe approach and alignment.

- **Testing**
  - Extended `tests/test_labware.py` to:
    - Assert that `WellPlate.get_initial_position()` equals the A1 well center.
    - Assert that constructing a `WellPlate` without `A1` raises a `ValidationError`.
    - Assert that `Vial.get_initial_position()` equals the configured `center` coordinate.

## Offset-based well generation

- **What was added**
  - A helper `generate_wells_from_offsets` in `well_plate.py` (exported via `src.labware`) that builds a full `wells: Dict[str, Coordinate3D]` mapping from:
    - `row_labels` (e.g. `['A','B',...,'H']`)
    - `column_indices` (e.g. `[1,2,...,12]`)
    - an `a1_center` anchor
    - `x_offset_mm` / `y_offset_mm` between adjacent wells
    - an optional `rounding_decimals` parameter.
  - This mirrors the classic `_well_to_xy` logic but returns full `Coordinate3D` objects suitable for constructing a `WellPlate`.

- **How it ties to YAML**
  - A compact YAML description can now specify:
    - A1 absolute center.
    - X/Y offsets between wells.
    - Row labels and column indices.
  - Loader code can call `generate_wells_from_offsets(...)` to materialize the `wells` dict for `WellPlate`, avoiding hand-maintained per-well coordinates.

- **Testing**
  - Added `test_generate_wells_from_offsets` to assert that a simple 2x2 layout (rows `['A','B']`, columns `[1,2]`) produces the expected coordinates for `A1`, `A2`, `B1`, and `B2` based on the configured offsets and A1 anchor.


# 2026-02-12

## Task
Validate test coverage after gantry refactor and restore failing tests.

## Work Completed
- Updated test imports from removed paths to new gantry package paths:
  - `src.hardware.gantry` -> `src.gantry.gantry`
  - `src.instrument_drivers.cnc_driver.driver` -> `src.gantry.gantry_driver.driver`
- Refactored `tests/test_cnc.py` to validate the current `Gantry` wrapper behavior.
- Added `pytest.ini` with `testpaths = tests` so operational scripts under `test_scripts/` are not collected as unit tests.
- Fixed package import in `src/gantry/gantry.py` to use a package-relative import:
  - `from .gantry_driver.driver import Mill`
- Added `src/gantry/__init__.py` export:
  - `from .gantry import Gantry`
- Updated `tests/test_driver_logic.py` command string assertions to match float-formatted G-code output.
- Fixed a hanging unit test by stubbing post-connect initialization calls in `test_mock_connection`.

## Issues Found
- Test collection failures due to stale import paths after refactor.
- `pytest` attempted to collect `test_scripts/cnc/test_move_left.py`, which imports removed modules and is not a unit test.
- A legacy connection test hung because `Mill.connect_to_mill()` now performs deeper setup that was not fully mocked.

## Resolution
- Repointed all failing test imports to the new package locations.
- Scoped pytest discovery to `tests/` only.
- Strengthened mocks for `connect_to_mill()`-related setup calls in the relevant unit test.

## Validation
- Ran targeted refactor-related tests:
  - `pytest -q tests/test_cnc.py tests/test_gantry.py tests/test_driver_logic.py tests/test_base_instrument.py`
  - Result: `19 passed`
- Ran full suite:
  - `pytest -q`
  - Result: `60 passed`

## Notes
- No hardware commands were executed. All validation was via mocked/unit tests only.

---

## Strict deck YAML and labware volume/calibration

### Task
Implement strict deck YAML configuration: deck file defines labware only (no gantry); YAML is validated strictly (missing/extra/wrong-type fields fail); well plates use two-point calibration (A1 + A2, axis-aligned) and derived well geometry; add volume fields to WellPlate and Vial; output `dict[str, Labware]` keyed by YAML names.

### Work completed
- **Tests (TDD)**: Added `tests/test_deck_loader.py` with 19 tests covering: valid load and derived wells/volume; two-point calibration in all four axis-aligned orientations (horizontal inc/dec, vertical inc/dec); invalid calibration (diagonal, identical points); missing required fields (top-level `labware`, well plate fields, vial fields); extra fields (top-level, per-entry); type coercion (numeric strings allowed, non-coercible fails); volume validation (working_volume_ul <= capacity_ul, positive); empty `labware: {}` allowed. Extended `tests/test_labware.py` with volume and extra-field tests for WellPlate and Vial.
- **Labware models**: Added `capacity_ul` and `working_volume_ul` to `WellPlate` and `Vial` with validators (positive, working <= capacity). Set `model_config = ConfigDict(extra="forbid")` on `Coordinate3D`, `Labware`, and subclasses so unknown fields raise `ValidationError`.
- **Deck schema**: Added `src/labware/deck_schema.py` with `DeckSchema` (single required key `labware`), `WellPlateEntry` (type, name, model, rows, columns, dimensions, a1, calibration.a2, x_offset_mm, y_offset_mm, capacity_ul, working_volume_ul) and `VialEntry` (type, name, model, height_mm, diameter_mm, center, vials, capacity_ul, working_volume_ul). Discriminated union on `type`; all schemas use `extra='forbid'`. Two-point calibration validator: A1 and A2 must be axis-aligned (same x or same y) and not identical.
- **Deck loader**: Added `src/labware/deck_loader.py` with `load_labware_from_deck_yaml(path)` that parses YAML, validates with `DeckSchema`, then builds `WellPlate` or `Vial` for each entry. Well positions are derived from A1, calibration A2, and offsets (columns-along-X or columns-along-Y depending on A2); row labels A–Z for up to 26 rows.
- **Sample config**: Added `configs/deck.sample.yaml` with one well plate and one vial matching the strict schema.

### Issues and resolutions
- None. All 30 tests (19 deck loader + 11 labware) pass.

### Design decisions
- Deck YAML contains **labware only**; gantry/serial settings are not in the deck file (per plan).
- Board/instrument YAML and loader are **deferred**; not implemented in this change.
- Two-point calibration: A2 must share either x or y with A1; diagonal or identical points raise `ValidationError`.
- Row labels limited to A–Z (1–26 rows) for simplicity; can be extended later for more rows.

---

## Single-vial model refactor and class-level field clarity

### Task
Refactor `Vial` to represent a single vial (not a vial rack), move concrete `name`/location-facing fields into `WellPlate` and `Vial` so each class directly communicates YAML requirements, and keep `Labware` as a high-level behavior base.

### Work completed
- **Labware base simplification** (`src/labware/labware.py`):
  - Removed data fields (`name`, `locations`) from `Labware`.
  - Kept high-level shared behavior only (`validate_name`, abstract-style `get_location`, `get_initial_position`).
- **WellPlate clarity** (`src/labware/well_plate.py`):
  - Added explicit `name` field on the concrete class.
  - Kept explicit `wells` mapping and well-centric lookup.
  - Added `get_location(location_id)` implementation that delegates to `get_well_center`.
- **Vial single-object redesign** (`src/labware/vial.py`):
  - Replaced rack-style `vials` mapping and `center` with a single `location: Coordinate3D`.
  - Updated accessors: `get_vial_center()` returns the single location; `get_location()` supports default / `"A1"` / vial name aliases.
  - Kept strict geometry and volume validation.
- **Deck schema/loader updates**:
  - `src/labware/deck_schema.py`: `VialEntry` now requires `location` (removed `vials` and `center`).
  - `src/labware/deck_loader.py`: builds `Vial` from `location`.
  - `configs/deck.sample.yaml`: updated vial example to the new single-location schema.
- **Tests updated**:
  - `tests/test_labware.py`: replaced base `Labware` data-field tests with concrete `WellPlate`/`Vial` tests; converted vial tests to single-location semantics.
  - `tests/test_deck_loader.py`: updated vial fixture/expectations to use `location`.

### Validation
- Targeted tests:
  - `pytest tests/test_labware.py tests/test_deck_loader.py -v` -> **31 passed**
- Full suite:
  - `pytest tests -q` -> **83 passed**

### Notes
- No hardware commands were executed; all validation used unit tests only.

---

## PR review fixes: safety, validation, and loader ergonomics

### Task
Address PR review feedback across deck loader and labware models: preserve traceback chaining, tighten CNC-safe numeric validation, enforce plate integrity constraints, clean up vial API behavior, and add missing loader-safe-path tests.

### Work completed
- **Exception chaining** (`src/labware/deck/loader.py`)
  - Updated `load_labware_from_deck_yaml_safe` to raise `DeckLoaderError(... ) from exc` (instead of `from None`) to preserve original traceback context.
- **Finite coordinate validation** (`src/labware/labware.py`)
  - Added `Coordinate3D` field validator rejecting non-finite values (`NaN`, `Inf`, `-Inf`).
- **WellPlate integrity checks** (`src/labware/well_plate.py`)
  - Added field constraints: `rows > 0`, `rows <= 26`, `columns > 0`.
  - Added cross-field validator ensuring `len(wells) == rows * columns`.
  - This prevents plates declaring inconsistent geometry (e.g. 96 wells declared with 1 actual well).
- **Schema constraints** (`src/labware/deck/schema.py`)
  - Added `gt=0` for `WellPlateEntry.rows` and `WellPlateEntry.columns`.
  - Added validation that `x_offset_mm` and `y_offset_mm` are non-zero.
- **Calibration semantics guard** (`src/labware/deck/loader.py`)
  - Added explicit assertion-like checks that `calibration.a2` corresponds to adjacent physical A2 step:
    - horizontal mode: `delta x == x_offset_mm`
    - vertical mode: `delta y == y_offset_mm`
- **Typing improvement** (`src/labware/deck/loader.py`)
  - Added explicit `_point_to_coord(p: _Point3D)` annotation.
- **Vial cleanup** (`src/labware/vial.py`)
  - Removed dead `_validate_location` validator (redundant with required field validation).
  - Removed implicit `"A1"` alias from `get_location`; now only `None` or vial `name` resolve.
- **Tests added/updated**
  - Added tests for:
    - safe loader YAML parse errors
    - safe loader missing-file behavior
    - non-finite `Coordinate3D` rejection
    - strict well-count validation
    - row upper bound enforcement
    - vial location alias removal (`"A1"` now errors)
  - Updated existing passing tests to satisfy strict well-count validator.

### Validation
- Targeted: `pytest tests/test_labware.py tests/test_deck_loader.py -q` -> **38 passed**
- Full suite: `pytest tests -q` -> **183 passed**

### Notes
- No hardware commands were executed; all validation used unit tests only.

---

## Friendly deck loader exceptions (no traceback in sample script)

### Task
Provide clean user-facing deck loader errors (emoji + explanation + fix guidance) without full tracebacks when running the sample loader script, implemented in core `deck_loader` code.

### Work completed
- Added **core exception utilities** in `src/labware/deck_loader.py`:
  - `DeckLoaderError` (user-facing exception type)
  - `_format_loader_exception(path, error)` (concise formatting + actionable guidance)
  - `load_labware_from_deck_yaml_safe(path)` (wraps raw loader and raises `DeckLoaderError` with friendly message)
- Updated `show_deck_objects.py`:
  - now uses `load_labware_from_deck_yaml_safe`
  - catches `DeckLoaderError` and prints only the formatted message (no traceback dump)
- Fixed sample config issue that was causing the traceback:
  - `configs/deck.sample.yaml`: corrected `plate_1.calibration.a2.y` from `-13.0` to `-10.0` (axis-aligned with `a1`)
- Added test coverage:
  - `tests/test_deck_loader.py::test_safe_loader_returns_clean_error_message`
  - validates emoji prefix and fix guidance presence.

### Validation
- Targeted:
  - `pytest tests/test_deck_loader.py tests/test_labware.py -q` -> **32 passed**
- Full suite:
  - `pytest tests -q` -> **83 passed**
- Manual friendly-error check:
  - Triggered a diagonal calibration YAML through `load_labware_from_deck_yaml_safe`
  - Verified output is a concise `❌ ...` message with `How to fix:` guidance.

### Notes
- No hardware commands were executed; all validation used unit tests only.

---

## Add model_name and sample deck inspection script

### Task
Add `model_name` as a required attribute for both `WellPlate` and `Vial`, propagate the change through strict deck schema/loading and sample YAML, and provide a simple script to load `configs/deck.sample.yaml` and print the resulting objects.

### Work completed
- Added required `model_name` fields to:
  - `src/labware/well_plate.py`
  - `src/labware/vial.py`
- Updated strict deck schema keys:
  - `src/labware/deck_schema.py`: `model` -> `model_name` for both `WellPlateEntry` and `VialEntry`.
- Updated object construction path:
  - `src/labware/deck_loader.py` now passes `model_name` into `WellPlate` and `Vial`.
- Updated sample YAML:
  - `configs/deck.sample.yaml` now uses `model_name`.
- Updated tests:
  - `tests/test_labware.py`: all `WellPlate`/`Vial` constructions now include `model_name`.
  - `tests/test_deck_loader.py`: all YAML fixtures now use `model_name`.
- Added sample script:
  - `show_deck_objects.py` prints loaded deck object mappings with full `model_dump()` output.

### Issues and resolutions
- **Pydantic warning**: `model_name` conflicts with the default `model_` protected namespace.
  - **Resolution**: set `protected_namespaces=()` in:
    - `WellPlate`
    - `Vial`
    - `WellPlateEntry`
    - `VialEntry`
  - This removed warnings while keeping strict validation behavior.

### Validation
- Targeted:
  - `pytest tests/test_labware.py tests/test_deck_loader.py -q` -> **31 passed**
- Full suite:
  - `pytest tests -q` -> **83 passed**

### Notes
- No hardware commands were executed; all validation used unit tests only.

---

## Deck loader builder kwargs refactor

### Task
Refactor deck loader so WellPlate and Vial are built from entry-derived kwargs instead of hand-mapping every field, reducing duplicate maintenance when model or schema fields change.

### Work completed
- Added **`_entry_kwargs_for_model(entry, model_class)`** in `src/labware/deck_loader.py`:
  - Builds constructor kwargs from `entry.model_dump()` filtered to keys present on `model_class.model_fields`.
  - Entry-only fields (e.g. `type`, `a1`, `calibration`, `x_offset_mm`, `y_offset_mm` for well plate) are dropped automatically.
- Refactored **`_build_well_plate`**:
  - Uses `_entry_kwargs_for_model(entry, WellPlate)` then sets `kwargs["wells"] = _derive_wells_from_calibration(entry)` and instantiates `WellPlate(**kwargs)`.
- Refactored **`_build_vial`**:
  - Uses `_entry_kwargs_for_model(entry, Vial)` then sets `kwargs["location"] = _point_to_coord(entry.location)` and instantiates `Vial(**kwargs)`.

### Validation
- Targeted: `pytest tests/test_deck_loader.py tests/test_labware.py -q` -> **32 passed**
- Full suite: `pytest tests -q` -> **84 passed**

### Notes
- No new tests were added; existing deck and labware tests lock behavior. YAML contract and loader behavior unchanged.
# 2026-02-12

## Task
Validate test coverage after gantry refactor and restore failing tests.

## Work Completed
- Updated test imports from removed paths to new gantry package paths:
  - `src.hardware.gantry` -> `src.gantry.gantry`
  - `src.instrument_drivers.cnc_driver.driver` -> `src.gantry.gantry_driver.driver`
- Refactored `tests/test_cnc.py` to validate the current `Gantry` wrapper behavior.
- Added `pytest.ini` with `testpaths = tests` so operational scripts under `test_scripts/` are not collected as unit tests.
- Fixed package import in `src/gantry/gantry.py` to use a package-relative import:
  - `from .gantry_driver.driver import Mill`
- Added `src/gantry/__init__.py` export:
  - `from .gantry import Gantry`
- Updated `tests/test_driver_logic.py` command string assertions to match float-formatted G-code output.
- Fixed a hanging unit test by stubbing post-connect initialization calls in `test_mock_connection`.

## Issues Found
- Test collection failures due to stale import paths after refactor.
- `pytest` attempted to collect `test_scripts/cnc/test_move_left.py`, which imports removed modules and is not a unit test.
- A legacy connection test hung because `Mill.connect_to_mill()` now performs deeper setup that was not fully mocked.

## Resolution
- Repointed all failing test imports to the new package locations.
- Scoped pytest discovery to `tests/` only.
- Strengthened mocks for `connect_to_mill()`-related setup calls in the relevant unit test.

## Validation
- Ran targeted refactor-related tests:
  - `pytest -q tests/test_cnc.py tests/test_gantry.py tests/test_driver_logic.py tests/test_base_instrument.py`
  - Result: `19 passed`
- Ran full suite:
  - `pytest -q`
  - Result: `60 passed`

## Notes
- No hardware commands were executed. All validation was via mocked/unit tests only.

---

# UV-Vis CCS Spectrometer Instrument Driver

## Summary

Ported the Thorlabs CCS100 UV-Vis spectrometer driver from `mofcat-workflow-main/devices/ccs100.py` into PANDA_CORE using the `BaseInstrument` abstraction pattern.

## Work Done

### New files created: `src/instruments/uvvis_ccs/`

| File | Purpose |
|------|---------|
| `exceptions.py` | `UVVisCCSError` hierarchy (Connection, Measurement, Timeout) |
| `models.py` | `UVVisSpectrum` frozen dataclass with `is_valid` / `num_pixels` |
| `driver.py` | `UVVisCCS(BaseInstrument)` — real DLL driver via ctypes |
| `mock.py` | `MockUVVisCCS(BaseInstrument)` — test double with `command_history` |
| `__init__.py` | Public exports |

### New test file: `tests/test_uvvis_ccs.py`
- 30 tests covering: model validation, exception hierarchy, synthetic spectrum helper, driver lifecycle (mocked ctypes), measure flow, mock command tracking
- All 30 pass; 46 existing tests unaffected

### Documentation updates
- `src/instruments/README.md` — new file listing all instruments with vendor labels
- `AGENTS.md` — added uvvis_ccs section
- `README.md` — added usage example for UVVisCCS

## Key Design Decisions

- **DLL loading deferred to `connect()`** — original mofcat code loaded the DLL at module import time; now it's lazy and testable
- **`measure()` returns `UVVisSpectrum` dataclass** — instead of a raw `(wavelengths, intensities)` tuple
- **Errors wrapped in typed hierarchy** — `UVVisCCSTimeoutError` replaces bare `RuntimeError`
- **Wavelengths stored as `tuple[float, ...]`** — no numpy dependency; keeps the instrument driver pure Python
- **Constructor params instead of hardcoded config** — serial number, DLL path, integration time all configurable

## What Was Left Out (intentionally)
- Gantry positioning — PANDA_CORE has its own gantry
- Google Sheets logging — workflow-level, not instrument-level
- Scan scheduling / orchestration — belongs in protocol engine

---

## Session 3: `setup/hello_world.py` — First-run interactive jog test

### New files created: `setup/`

| File | Purpose |
|------|---------|
| `setup/hello_world.py` | Interactive first-run script: connect, home, jog with arrow keys |
| `setup/keyboard_input.py` | Helper for reading raw keypresses (arrow keys, letters) via `tty`/`termios` |

### How it works
1. Connects to gantry via auto-scan (no config needed)
2. Checks `is_healthy()` before proceeding
3. User presses Enter to home the machine
4. Enters jog loop: arrow keys move X/Y ±1mm, Z/X keys move Z ±1mm, Q quits
5. Coordinates printed after each move, clamped to working volume
6. Graceful disconnect on exit or Ctrl+C

### Documentation updates
- `AGENTS.md` — added `setup/` section

---

## Session 4: Opentrons Pipette Instrument Driver

### Summary

Added an Opentrons pipette driver to `src/instruments/pipette/` following the BaseInstrument pattern. Supports OT-2 and Flex pipette models (10 total). Communicates via Arduino serial using the Pawduino firmware protocol. The P300 single-channel uses real calibrated values from PANDA-BEAR; other models have placeholder positions pending hardware calibration.

### New files created: `src/instruments/pipette/`

| File | Purpose |
|------|---------|
| `exceptions.py` | `PipetteError` hierarchy (Connection, Command, Timeout, Config) |
| `models.py` | `PipetteConfig`, `PipetteStatus`, `AspirateResult`, `MixResult` frozen dataclasses; `PipetteFamily` enum; `PIPETTE_MODELS` registry (10 models) |
| `driver.py` | `Pipette(BaseInstrument)` — real serial driver with Pawduino protocol |
| `mock.py` | `MockPipette(BaseInstrument)` — test double with `command_history` |
| `__init__.py` | Public exports |

### New test file: `tests/instruments/pipette/test_pipette.py`
- 61 tests covering: model validation, exception hierarchy, response parsing, driver constructor, driver lifecycle (mocked serial), all commands (mocked serial), mock command tracking
- All 61 pass; 82 existing tests unaffected (143 total)

### Documentation updates
- `src/instruments/README.md` — added pipette row
- `AGENTS.md` — added pipette section

### Key Design Decisions
- **Config as in-code registry** — `PIPETTE_MODELS` dict, no JSON file I/O
- **Self-contained serial** — driver owns its own `serial.Serial`, no shared ArduinoLink
- **Volume tracking excluded** — application-level concern, not driver-level
- **Thread-safe** — `_send_command` uses `threading.Lock`
- **Deferred connection** — serial port not opened until `connect()` is called

### Pawduino Command Codes
| Code | Command |
|------|---------|
| 10 | Home |
| 11 | Move to position |
| 12 | Aspirate |
| 13 | Dispense |
| 14 | Status query |
| 15 | Mix |
| 28 | Drip stop |

### Notes
- No hardware commands executed. All validation via mocked/unit tests only.
- `pyserial` was installed as a new dependency.

---

## Session 5: Add offset and depth to BaseInstrument

### Summary
Added `offset_x`, `offset_y`, and `depth` as instance attributes to `BaseInstrument`, allowing every instrument driver to describe its physical position relative to the router. All default to `0.0`.

### Files modified
- `src/instruments/base_instrument.py` — added `offset_x`, `offset_y`, `depth` params to `__init__`
- `src/instruments/filmetrics/driver.py` — pass through offset/depth params
- `src/instruments/filmetrics/mock.py` — pass through offset/depth params
- `src/instruments/uvvis_ccs/driver.py` — pass through offset/depth params
- `src/instruments/uvvis_ccs/mock.py` — pass through offset/depth params
- `src/instruments/pipette/driver.py` — pass through offset/depth params
- `src/instruments/pipette/mock.py` — pass through offset/depth params
- `tests/instruments/test_base_instrument.py` — added 2 tests for default and custom offset/depth

### Validation
- `pytest -q` — 145 passed, 0 failed

---

## Deck package reorganization + calibration nesting update

### Task
Move deck-related code into `src/labware/deck/`, split `DeckLoaderError` into a dedicated module, and update deck YAML processing to support calibration points under `calibration.a1` and `calibration.a2` (with sample YAML using nested calibration points).

### Work completed
- Moved deck modules into package path:
  - Added `src/labware/deck/__init__.py`
  - Added `src/labware/deck/loader.py`
  - Added `src/labware/deck/schema.py`
  - Added `src/labware/deck/errors.py` (contains `DeckLoaderError`)
- Removed old module locations:
  - Deleted `src/labware/deck_loader.py`
  - Deleted `src/labware/deck_schema.py`
- Updated imports:
  - `src/labware/__init__.py` now re-exports from `src/labware/deck/`
  - `tests/test_deck_loader.py` imports from `src.labware.deck.loader`
  - `README.md` example import updated to `src.labware.deck.loader`
- Updated schema/loader for nested calibration points:
  - `WellPlateEntry` now supports canonical `calibration.a1` and `calibration.a2`
  - Loader derives wells using `entry.calibration.a1` / `entry.calibration.a2` path via canonical `a1_point`
  - Kept backward-compatible fallback for top-level `a1` during transition
- Updated sample config:
  - `configs/deck.sample.yaml` now places A1 and A2 both under `calibration`
- Updated AGENTS docs for new deck package file paths and calibration layout.

### Validation
- Targeted: `pytest tests/test_deck_loader.py tests/test_labware.py -q` -> **32 passed**
- Full suite: `pytest tests -q` -> **177 passed**

### Notes
- No hardware commands were executed; all validation used unit tests only.
